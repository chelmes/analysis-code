#!/hadron/knippsch/Enthought/Canopy_64bit/User/bin/python
##!/usr/bin/python

import numpy as np
import scipy.stats
import matplotlib
matplotlib.use('Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

import analysis2 as ana

def print_summary(datafolder, plotfolder, lattices, irreps=[["A1"]]):
    """Print a summary of the lattices given.

    Parameters
    ----------
    datafolder : string
        Path to the data.
    plotfolder : 
        Path for the plots.
    lattices: list of strings
        The lattices to use.
    irreps : list of list of strings
        The "outer" list gives the totel momentum to use,
        the inner which irreps to read in.
    """
    ## variables
    verbose = True
    xcut = None
    readnewdata = True
    al = 0.9

    # read data
    fname = "%s/summary/collected_delta.npz" % datafolder
    if readnewdata:
        if verbose:
            print("reading new data")
        # create overall list
        q2 = []
        delta = []
        # iterate over the lattices and save the data
        for lat in lattices:
            if verbose:
                print("reading data for lattice: %s" % lat)
            #fname = "%s/summary/collected_delta_%s.npz" % (datafolder, lat)
            lq2 = []
            ldelta = []
            # iterate over the total momentum
            for p2, irr in enumerate(irreps):
                if verbose:
                    print("reading data for total momentum: %d" % p2)
                lq2.append([])
                ldelta.append([])
                # iterate over the irreps
                for ir in irr:
                    if verbose:
                        print("reading data for irrep: %s" % ir)
                    # get file names
                    if ir == "A1":
                        fileq2 = "q2_TP%d.npz" % p2
                        filedelta = "delta_TP%d.npz" % p2
                    else:
                        fileq2 = "q2_TP%d_%s.npz" % (p2, ir)
                        filedelta = "delta_TP%d_%s.npz" % (p2, ir)
                    # read data
                    if verbose:
                        print("read data")
                    tmpq2 = ana.FitResult.read("%s/%s/%s" % (datafolder, lat, fileq2))
                    tmpdelta = ana.FitResult.read("%s/%s/%s" % (datafolder, lat, filedelta))
                    # calc mean
                    tmpq2.calc_error()
                    tmpdelta.calc_error()
                    # get the needed data and append
                    tmp = [tmpq2.error[0][0][0], tmpq2.error[0][1][0],
                           tmpq2.error[0][2][0][0], tmpq2.error[0][2][0][1]]
                    lq2[-1].append(tmp)
                    tmp = [tmpdelta.error[0][0][0], tmpdelta.error[0][1][0],
                           tmpdelta.error[0][2][0][0], tmpdelta.error[0][2][0][1]]
                    ldelta[-1].append(tmp)
                    if verbose:
                        print("extracted data")
            #lq2 = np.asarray(lq2)
            #ldelta = np.asarray(ldelta)
            #np.savez(fname, q2=lq2, delta=ldelta)
            q2.append(lq2)
            delta.append(ldelta)
        if verbose:
            print("finished reading data")
    else:
        pass
        #raise ValueError("Not implemented yet")
        #if verbose:
        #    print("read compiled data")
        ## create overall list
        #q2 = []
        #delta = []
        ## iterate over the lattices and save the data
        #for lat in lattices:
        #    if verbose:
        #      print("read data for lattice: %s" % lat)
        #    fname = "%s/summary/collected_delta_%s.npz" % (datafolder, lat)
        #    tmpf = np.load(fname)
        #    q2.append(tmpf["q2"])
        #    delta.append(tmpf["delta"])
        #    del tmpf
        #if verbose:
        #    print("finished reading data")

    if verbose:
        print("setting up plot")
    # plot everything
    if xcut:
        plotter = ana.LatticePlot("%s/delta_q2_xcut%.1f_TP%d.pdf" % (plotfolder, xcut, 0))
    else:
        plotter = ana.LatticePlot("%s/delta_q2_TP%d.pdf" % (plotfolder, 0))
    # set title etc.
    plotter.set_title("", ["q$^2$", "$\delta$ ($^\circ$)"])

    # symbol code the irrep
    irrepfmt = {"A1":"o", "E":"s", "T2":"D", "B1":"^"}
    ensfmt = {0:"o", 1:"s", 2:"D", 3:"^"}
    # color code the total momentum
    p2fmt = ["r", "b", "g", "m", "c", "y", "k"]
    # plot the data
    # iterate over the lists
    # q2[lattice][total momentum][irrep]
    for i, a in enumerate(q2):
        if verbose:
            print("plotting lattice: %s" % lattices[i])
        for p2, b in enumerate(a):
            if verbose:
                print("plotting momentum: %d" % p2)
            for ir, c in enumerate(b):
                if verbose:
                    print("plotting irrep: %s" % irreps[p2][ir])
                # just for convenience
                d = delta[i][p2][ir]
                x = c[0][0]
                y = d[0][0]
                if y > 0:
                    y -= 180.
                # each entry of the list has to be iterable
                dxtot = [[np.sqrt(c[1]**2 + c[2]**2)], [np.sqrt(c[1]**2 + c[3]**2)]]
                dytot = [[np.sqrt(d[1]**2 + d[2]**2)], [np.sqrt(d[1]**2 + d[3]**2)]]
                # build the format for plotting
                fmt = "".join((ensfmt[i], p2fmt[p2]))
                #fmt = "".join((irrepfmt[irreps[p2][ir]], p2fmt[p2]))
                # buld the label for the data
                lab = "%s, p$^2$=%d (G)" % (lattices[i], p2)
                #lab = "%s, p$^2$=%d" % (irreps[p2][ir], p2)
                #alp = 1. - 0.25*float(i)
                plt.errorbar(x, y, yerr=dytot, xerr=dxtot, fmt=fmt, label="",
                    alpha=al)
                plt.errorbar(x, y, yerr=d[1], xerr=c[1], fmt=fmt, label=lab,
                    alpha=al)
    #if verbose:
    #    print("finishing plot")

    # plot points from Dudek analysis
    print("plotting dudek's points")
    x24 = np.asarray([0.105, 1.961e-01])
    dx24 = np.asarray([0.034, 7.756e-03])
    y24 = np.asarray([-21.163, -1.165*180./np.pi])
    dy24 = np.asarray([0.337, 4.055e-02*180./np.pi])
    fmt = "".join((ensfmt[1], p2fmt[2]))
    lab1 = "A40.24, p$^2$=0,1 (D)"
    plt.errorbar(x24, y24, yerr=dy24, xerr=dx24, fmt=fmt, label=lab1, alpha=al)
    fmt = "".join((ensfmt[1], p2fmt[3]))
    x32 = np.asarray([0.01, 0.2145])
    dx32 = np.asarray([0.001, 0.0043])
    y32 = np.asarray([-1.026, 146.961189087-180.])
    dy32 = np.asarray([0.185, 1.])
    lab1 = "A40.32, p$^2$=0,1 (D)"
    plt.errorbar(x32, y32, yerr=dy32, xerr=dx32, fmt=fmt, label=lab1, alpha=al)

    # plot function of delta
    dofp0 = lambda p, x: np.arctan(1./(1./(p[0]*x)+0.5*p[1]*x))*180/np.pi
    dofp2 = lambda p, x: np.arctan(p[0]*np.power(x, 5))*180/np.pi
    ran = [1e-3, 2.*0.145]
    #fname = "%s/globalfit/gfitdata.npz" % datafolder
    fname = "%s/globalfit/gfitdata_new.npz" % datafolder
    f = np.load(fname)
    #f = np.load("test_data.npz")
    tmp = f['res']
    # deal with result array
    #print(tmp[:,0])
    res = np.zeros_like(tmp)
    res[:,0] = 1./tmp[:,0]
    res[:,2] = 1./tmp[:,2]
    res[:,1] = tmp[:,1]
    data = ana.compute_error(res)
    chi2 = f['chi2']
    pval = 1. - scipy.stats.chi2.cdf(chi2, 16)
    print("nb of data %d, chi^2 = %.2f, p = %.2f" % (res.shape[0], chi2[0], pval[0]))
    print("a_0 = %.2f +- %.2f" % ( data[0][0], data[1][0]))
    print("r_0 = %.2f +- %.2f" % ( data[0][1], data[1][1]))
    print("a_2 = %.2f +- %.2f" % ( data[0][2], data[1][2]))

    nsamples = 100
    # sample liumings results
    #res_l = np.zeros((nsamples, 3))
    #np.random.seed(1228)
    #res_l[:,0] = 0.02*np.random.randn(nsamples) - 1.3
    #np.random.seed(1228)
    #res_l[:,1] = 0.7*np.random.randn(nsamples) + 14.1
    #np.random.seed(1228)
    #res_l[:,2] = 26.*np.random.randn(nsamples) - 46.
    # sample Dudek et al's result, using mpi*a_i
    #mpi_dudek = np.zeros((nsamples,))
    #np.random.seed(1228)
    #mpi_dudek = 0.00013*np.random.randn(nsamples) + 0.06906
    #res_d = np.zeros((nsamples, 3))
    #np.random.seed(1228)
    #res_d[:,0] = (0.013*np.random.randn(nsamples) - 0.307)/mpi_dudek
    #np.random.seed(1228)
    #res_d[:,1] = (0.13*np.random.randn(nsamples) - 0.26)/mpi_dudek
    #np.random.seed(1228)
    #res_d[:,2] = (0.53*np.random.randn(nsamples) - 1.89)/np.power(mpi_dudek,5)*1e-6

    # plot the functions
    #plotter.plot_func(dofp0, res_l[:,:2], ran, "$\delta_0$ (l)", fmt="b", col="b")
    plotter.plot_func(dofp0, res[:,:2], ran, "$\delta_0$ (GF)", col="k", ploterror=False)
    #plotter.plot_func(dofp0, tmp[:,:2], ran, "$\delta_0$ (c)", fmt="c", col="c")
    #plotter.plot_func(dofp0, res_d[:,:2], ran, "$\delta_0$ (d)", fmt="r", col="r")
    #plotter.plot_func(dofp2, res_l[:,(2,0)], ran, "$\delta_2$ (l)", fmt="--b", col="b")
    #plotter.plot_func(dofp2, res[:,(2,0)], ran, "$\delta_2$ (GF)", fmt="--k", col="k")
    #plotter.plot_func(dofp2, res[:,(2,0)], ran, "$\delta_2$ (c)", fmt="--k", col="k")
    #plotter.plot_func(dofp2, res_d[:,(2,0)], ran, "$\delta_2$ (d)", fmt="--r", col="r")

    plt.legend(numpoints=1, loc=0, framealpha=0.6)
    plt.grid(True)
    plotter.save()
    del plotter
    return

def main():
    Aens = ["A40.24", "A40.32"]
    #Aens = ["A40.20", "A40.24", "A40.32"]
    datafolder = "./data/I2/"
    plotfolder = "./plots/I2/summary/"
    # construct list with irreps, giving also total momentum
    irreps = [["A1"], ["A1"]]
    print_summary(datafolder, plotfolder, Aens, irreps)
    return

# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
