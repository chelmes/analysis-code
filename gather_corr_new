#!/hadron/knippsch/Enthought/Canopy_64bit/User/bin/python
##!/usr/bin/python2
################################################################################
#
# Author: Christian Jost (jost@hiskp.uni-bonn.de)
# Date:   Februar 2015
#
# Copyright (C) 2015 Christian Jost
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: At the moment this is a test program, this file will change a lot
#
# For informations on input parameters see the description of the function.
#
################################################################################

import os
import numpy as np
import ConfigParser

import analysis2 as ana

def main():
    if len(os.sys.argv) < 2:
        fname = "./ini/uncharged.ini"
    else:
        fname = os.sys.argv[1]
    # parse the input file for variables
    config = ConfigParser.SafeConfigParser()
    config.read(fname)
    debug = config.getint("main", "debug")
    #debug = 3
    inputpath = config.get("main", "inputpath")
    outputpath = config.get("main", "outputpath")
    confmax = config.getint("main", "confmax")
    confmin = config.getint("main", "confmin")
    confstep = config.getint("main", "confstep")
    nbran = config.getint("main", "nbran")
    # workaround: missing needs ints, config reads strings
    diag = config.get("main", "diagrams").split(",")
    miss = config.get("main", "missing").split(",")
    missing = []
    for m in miss:
        missing.append(int(m.strip()))
    diagrams = []
    for d in diag:
        diagrams.append(str(d.strip()))
    innames = ana.inputnames(fname, diagrams)

    inputlist = []
    for i in range(confmin, confmax, confstep):
        if i in missing:
            continue
        inputlist.append("cnfg%d/" % i)
    if debug > 0:
        print("number of files: %d" % len(innames))
        print("number of configs: %d" % len(inputlist))
    if debug > 1:
        print(inputpath)
        print(outputpath)
    if debug > 2:
        print(innames)
        print(inputlist)
        print(missing)

    for d in innames:
        if debug > 0:
            print(d)
        data = []
        # need to treat C1 differently
        if d.startswith("C1"):
            # read in data
            for i in inputlist:
                inname = "".join((inputpath, i, d))
                ## read in data
                tmp = np.fromfile(inname, dtype=complex).reshape((nbran, -1))
                data.append(tmp)
            # brind data into shape
            tmp = np.asarray(data)
            data = np.zeros((tmp.shape[0], tmp.shape[-1]), dtype=complex)
            #data = np.zeros(tmp.shape[:-1], dtype=complex)
            T = tmp.shape[2]
            # calc VEV
            #vev = np.mean(tmp)
            #print("vev = %f %+f" % (vev.real, vev.imag))
            #tmp -= vev
            # calc the correlation function
            for t1 in range(T):
                for t2 in range(T):
                    for r1 in range(nbran):
                        for r2 in range(nbran):
                            if r1 == r2:
                                continue
                            data[:,t1] += (tmp[:,r1,(t1+t2)%T].real * tmp[:,r2,t2].real
                                + 1.j*(tmp[:,r1,(t1+t2)%T].imag * tmp[:,r2,t2].imag))
            # normalize the correlation function
            data /= (float(nbran) * float(nbran-1))*float(T)
        else:
            for i in inputlist:
                inname = "".join((inputpath, i, d))
                ## read in data
                data.append(np.fromfile(inname, dtype=complex))
            data = np.asarray(data)
        # create a correlator from the data
        corrsr = ana.Correlators.create(np.atleast_3d(data).real)
        corrsi = ana.Correlators.create(np.atleast_3d(data).imag)
        # save the data
        outname = "".join((outputpath, d))
        if debug > 1:
            print("save data to %s" % outname)
        corrsr.save(outname.replace(".dat", "_real.dat"), asascii=True)
        corrsi.save(outname.replace(".dat", "_imag.dat"), asascii=True)
        corrsr.sym_and_boot(1500)
        corrsi.sym_and_boot(1500)

        # plot the data
        plotter = ana.LatticePlot(outname.replace(".dat", "_real.pdf"))
        labels = ["correlation function", "t", "C(t)", "data"]
        plotter.plot(corrsr, labels)
        if d.startswith("C20"):
            corrsr.data = -corrsr.data
            plotter.set_env(ylog=True)
            plotter.plot(corrsr, labels)
            corrsr.data = -corrsr.data
            plotter.set_env(ylog=False)
        elif d.startswith("C1"):
            corrsr.shift(1)
            plotter.plot(corrsr, labels)
        plotter.new_file(outname.replace(".dat", "_imag.pdf"))
        plotter.plot(corrsi, labels)

        labels = ["eff. mass", "t", "m(t)", "data"]
        corrsr.mass()
        corrsi.mass()
        #plotter.set_env(ylim=[0., 0.5])
        plotter.new_file(outname.replace(".dat", "_real_mass.pdf"))
        plotter.plot(corrsr, labels)
        plotter.new_file(outname.replace(".dat", "_imag_mass.pdf"))
        plotter.plot(corrsi, labels)

        del plotter

def build_pi0():
    # parse config
    if len(os.sys.argv) < 2:
        fname = "./ini/uncharged.ini"
    else:
        fname = os.sys.argv[1]
    config = ConfigParser.SafeConfigParser()
    config.read(fname)
    datapath = config.get("main", "outputpath")
    diag = config.get("main", "diagrams").split(",")
    diagrams = []
    for d in diag:
        diagrams.append(str(d.strip()))
    innames = ana.inputnames(fname, diagrams)
    for i in innames:
        if i.startswith("C1") and "_u_" in i:
            tmpname = "".join((datapath, i))
            tmpname = tmpname.replace(".dat", "_real.dat")
            print(tmpname)
            corrD = ana.Correlators(tmpname)
        elif i.startswith("C20") and "_uu_" in i:
            tmpname = "".join((datapath, i))
            tmpname = tmpname.replace(".dat", "_real.dat")
            print(tmpname)
            corrC = ana.Correlators(tmpname)

    newdata = -corrC.data + 2. * corrD.data

    pi0 = ana.Correlators.create(newdata)
    tmpname = "".join((datapath, "pi_corr_p0.dat"))
    pi0.save(tmpname, asascii=True)
    pi0.sym_and_boot(1500)
    plotter = ana.LatticePlot(tmpname.replace(".dat", ".pdf"))
    labels = ["correlation function", "t", "C(t)", "data"]
    plotter.plot(pi0, labels)
    pi0.shift(dt=1)
    plotter.plot(pi0, labels)

    plotter.set_env(ylim=[0., 0.3])
    pi0.mass()
    plotter.new_file(tmpname.replace(".dat", "_mass.pdf"))
    labels = ["eff. mass", "t", "m(t)", "data"]
    plotter.plot(pi0, labels)

    del plotter
    
# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    try:
        main()
        build_pi0()
    except KeyboardInterrupt:
        print("\nKeyboard Interrupt, exiting...")
