#!/hadron/knippsch/Enthought/Canopy_64bit/User/bin/python
##!/usr/bin/python2
################################################################################
#
# Author: Christian Jost (jost@hiskp.uni-bonn.de)
# Date:   Februar 2015
#
# Copyright (C) 2015 Christian Jost
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: At the moment this is a test program, this file will change a lot
#
# For informations on input parameters see the description of the function.
#
################################################################################

import os
import numpy as np
import ConfigParser

import analysis2 as ana

def main():
    if len(os.sys.argv) < 2:
        fname = "./ini/uncharged.ini"
    else:
        fname = os.sys.argv[1]
    # parse the input file for variables
    config = ConfigParser.SafeConfigParser()
    config.read(fname)
    debug = config.getint("main", "debug")
    #debug = 3
    inputpath = config.get("main", "inputpath")
    outputpath = config.get("main", "outputpath")
    confmax = config.getint("main", "confmax")
    confmin = config.getint("main", "confmin")
    confstep = config.getint("main", "confstep")
    nbranu = config.getint("main", "nbran")
    nbrans = nbranu-1
    # workaround: missing needs ints, config reads strings
    diag = config.get("main", "diagrams").split(",")
    miss = config.get("main", "missing").split(",")
    missing = []
    for m in miss:
        missing.append(int(m.strip()))
    diagrams = []
    for d in diag:
        diagrams.append(str(d.strip()))
    #innames = ana.inputnames(fname, ["C1"])
    innames = ana.inputnames(fname, diagrams)

    inputlist = []
    for i in range(confmin, confmax, confstep):
        if i in missing:
            continue
        inputlist.append("cnfg%d/" % i)
    if debug > 0:
        print("number of files: %d" % len(innames))
        print("number of configs: %d" % len(inputlist))
    if debug > 1:
        print(inputpath)
        print(outputpath)
    if debug > 2:
        print(innames)
        print(inputlist)
        print(missing)

    calcvev = False
    for d in innames:
        if debug > 0:
            print(d)
        data = []
        # need to treat C1 differently
        if d.startswith("C1"):
            if "_u_" in d:
                nbran = nbranu
            elif "_s_" in d:
                nbran = nbrans
            elif "_c_" in d:
                nbran = nbranc
            # read in data
            for i in inputlist:
                inname = "".join((inputpath, i, d))
                ## read in data
                tmp = np.fromfile(inname, dtype=complex).reshape((nbran, -1))
                data.append(tmp)
            # brind data into shape
            tmp = np.asarray(data)
            T = tmp.shape[-1]
            # print all single loops
            #for i in range(nbran):
            #    outname = "".join((outputpath, "/C1/", "rnd%d_loop.dat"%i))
            #    tst = np.zeros(tmp[:,i].shape+(2,))
            #    tst[:,:,0] = tmp[:,i].real
            #    tst[:,:,1] = tmp[:,i].imag
            #    ctmp = ana.Correlators.create(tst)
            #    ctmp.save(outname, True)
            # calc vev explicitly
            tst = np.zeros((tmp.shape[0],1,2))
            tst[:,0,0] = np.mean(tmp.real, axis=(1,2))
            tst[:,0,1] = np.mean(tmp.imag, axis=(1,2))
            outname = "".join((outputpath, "/C1/", "vev.dat"))
            ctmp = ana.Correlators.create(tst)
            ctmp.save(outname, True)
            # build all rnd vec combinations explicitly
            data = np.zeros(tmp[:,0].shape+(2,))
            for i in range(nbran):
                for j in range(nbran):
                    if i == j:
                        continue
                    tst = np.zeros_like(data)
                    for t1 in range(T):
                        for t2 in range(T):
                            dt = (t2 - t1 + T)%T
                            tst[:,dt,0] = np.multiply(tmp[:,j,t1].real,tmp[:,i,t2].real)
                            tst[:,dt,1] = -tmp[:,j,t1].imag*tmp[:,i,t2].imag
                        data += tst
            data /= (nbran*(nbran-1)*T)
        else:
            for i in inputlist:
                inname = "".join((inputpath, i, d))
                ## read in data
                data.append(np.fromfile(inname, dtype=complex))
            data = np.asarray(data)
            tmp = np.empty(data.shape + (2,))
            tmp[...,0] = data.real
            tmp[...,1] = data.imag
            data = tmp
        # create a correlator from the data
        corrs = ana.Correlators.create(data)
        # save the data
        outname = "".join((outputpath, d))
        if debug > 1:
            print("save data to %s" % outname)
        corrs.save(outname, asascii=True)

        # plot the data
        corrs.sym_and_boot(500)
        plotter = ana.LatticePlot(outname.replace(".dat", ".pdf"))
        labels = ["correlation function", "t", "C(t)", "data"]
        plotter.plot(corrs, labels)
        #plotter.set_env(ylog=True)
        #labels[0] = "correlation function, log plot"
        #plotter.plot(corrs, labels)
        plotter.set_env(ylog=False)
        corrs.shift(1)
        labels[0] = "correlation function, shifted"
        plotter.plot(corrs, labels)

        labels = ["eff. mass", "t", "m(t)", "data"]
        corrs.mass()
        plotter.plot(corrs, labels)

        del plotter

def build_eta():
    # parse config
    if len(os.sys.argv) < 2:
        fname = "./ini/uncharged.ini"
    else:
        fname = os.sys.argv[1]
    config = ConfigParser.SafeConfigParser()
    config.read(fname)
    datapath = config.get("main", "outputpath")
    diag = config.get("main", "diagrams").split(",")
    diagrams = []
    for d in diag:
        diagrams.append(str(d.strip()))
    innames = ana.inputnames(fname, diagrams)
    quarks = ["u", "s", "c"]
    corrD = {}
    corrC = {}
    for i, q1 in enumerate(quarks):
        for name in innames:
            if name.startswith("C1") and ("_%s_" % q1) in name:
                tmpname = "".join((datapath, name))
                # read imaginary part, located in the third column
                corrD[q1] = ana.Correlators(tmpname, column=(2,))
                continue

            for q2 in quarks[i:]:
                if name.startswith("C20") and ("_%s%s" % (q1, q2)) in name:
                    tmpname = "".join((datapath, name))
                    corrC["%s%s" % (q1, q2)] = ana.Correlators(tmpname)

    for q1 in quarks:
        for q2 in quarks:
            try:
                cC = corrC["%s%s" % (q1, q2)]
            except KeyError:
                continue
            if q1 == q2:
                cD = corrD[q1]
                newdata = -cC.data[...,0] - 0.5*cD.data[...,0]
            else:
                newdata = -cC.data[...,0]

            fname = "".join((datapath, "eta_%s%s_corr_p0.dat" % (q1, q2)))
            eta = ana.Correlators.create(np.atleast_3d(newdata))
            eta.save(fname, asascii=True)
            plotter = ana.LatticePlot(fname.replace(".dat", ".pdf"))
            labels = ["correlation function", "t", "C(t)", "data"]
            eta.sym_and_boot(1500)
            plotter.plot(eta, labels)
            plotter.set_env(ylog=True)
            plotter.plot(eta, labels)
            plotter.set_env(ylog=False)
            labels[0] = "shifted correlation function"
            eta.shift(dt=1)
            plotter.plot(eta, labels)
            plotter.set_env(ylog=True)
            plotter.plot(eta, labels)
            plotter.set_env(ylog=False)

            #plotter.set_env(ylim=[0., 0.2])
            eta.mass()
            #print(eta.data[0])
            labels = ["eff. mass", "t", "m(t)", "data"]
            plotter.plot(eta, labels)
            del plotter
            del eta
    
def build_pi0():
    # parse config
    if len(os.sys.argv) < 2:
        fname = "./ini/uncharged.ini"
    else:
        fname = os.sys.argv[1]
    config = ConfigParser.SafeConfigParser()
    config.read(fname)
    datapath = config.get("main", "outputpath")
    diag = config.get("main", "diagrams").split(",")
    diagrams = []
    for d in diag:
        diagrams.append(str(d.strip()))
    innames = ana.inputnames(fname, diagrams)
    for i in innames:
        if i.startswith("C1") and "_u_" in i:
            tmpname = "".join((datapath, i))
            #tmpname = tmpname.replace(".dat", "_real.dat")
            print(tmpname)
            corrD = ana.Correlators(tmpname)
        elif i.startswith("C20") and "_uu_" in i:
            tmpname = "".join((datapath, i))
            #tmpname = tmpname.replace(".dat", "_real.dat")
            print(tmpname)
            corrC = ana.Correlators(tmpname)

    newdata = -corrC.data[...,0] + 2. * corrD.data[...,0]

    pi0 = ana.Correlators.create(np.atleast_3d(newdata))
    tmpname = "".join((datapath, "pi_corr_p0.dat"))
    pi0.save(tmpname, asascii=True)
    plotter = ana.LatticePlot(tmpname.replace(".dat", ".pdf"))
    labels = ["correlation function", "t", "C(t)", "data"]
    pi0.sym_and_boot(1500)
    plotter.plot(pi0, labels)
    plotter.set_env(ylog=True)
    plotter.plot(pi0, labels)
    plotter.set_env(ylog=False)
    labels[0] = "shifted correlation function"
    pi0.shift(dt=1)
    plotter.plot(pi0, labels)
    plotter.set_env(ylog=True)
    plotter.plot(pi0, labels)
    plotter.set_env(ylog=False)

    #plotter.set_env(ylim=[0., 0.2])
    #print(pi0.data[0])
    pi0.mass(False)
    #print(pi0.data[0])
    labels = ["eff. mass", "t", "m(t)", "data"]
    plotter.plot(pi0, labels)
    del plotter

# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    try:
        main()
        build_pi0()
        build_eta()
    except KeyboardInterrupt:
        print("\nKeyboard Interrupt, exiting...")
