#!/usr/bin/python
################################################################################
#
# Author: Christian Jost (jost@hiskp.uni-bonn.de),
#         Christopher Helmes (helmes@hiskp.uni-bonn.de)
# Date:   October 2015
#
# Copyright (C) 2015 Christian Jost, Christopher Helmes
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: A short comparison of 2 pt and 4 pt correlation functions.
#
# For informations on input parameters see the description of the function.
#
################################################################################

import matplotlib
matplotlib.use('Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import math
import analysis as ana

def main():
  ## definition of some variables
    nbsamples = 500
    T = 64
    T2 = int(T/2)+1
    massfunc = lambda p, t: p

    # get mean correlators of 2 and 4pt function to compare

    parent = "/hiskp2/helmes/analysis/scattering/test/"
    #var = ["s_3_rnd_vec/","s_4_rnd_vec/","s_5_rnd_vec/"]
    var = ["s_3_rnd_vec/","s_5_rnd_vec/"]
    suff = "/k_charged/data/A30.32/amu_s_225/"

    corr_2pt = np.zeros((len(var), 200, T))
    corr_4pt_c = np.zeros((len(var),200, T))
    corr_4pt_d = np.zeros_like(corr_4pt_c)

    mean_2pt = np.zeros((len(var),T))
    err_2pt = np.zeros_like(mean_2pt)
    mean_4pt_d = np.zeros_like(mean_2pt)
    err_4pt_d = np.zeros_like(mean_2pt)
    mean_4pt_c = np.zeros_like(mean_2pt)
    err_4pt_c = np.zeros_like(mean_2pt)

    for i,v in enumerate(var):
      curr = parent+v+suff
      corr_2pt[i] = ana.read_data_ascii(curr+"k_charged_p0.dat")
      mean_2pt[i], err_2pt[i] = ana.calc_error(corr_2pt[i])
      corr_4pt_d[i] = ana.read_data_ascii(curr+"C4D.dat")
      mean_4pt_d[i], err_4pt_d[i] = ana.calc_error(corr_4pt_d[i])
      corr_4pt_c[i] = ana.read_data_ascii(curr+"C4C.dat")
      mean_4pt_c[i], err_4pt_c[i] = ana.calc_error(corr_4pt_c[i])

    # plot relative errors first
    print(np.divide(mean_2pt[0],mean_2pt[1]))
    print(err_2pt.shape)
    err_single = PdfPages(parent+"A30.32_rel_err.pdf")
    label = ['A30.32 rel error',r'$t/a$',r'$\delta (C_2)/C_2$',['nb_rnd 3','nb_rnd 5']]
    tlist = np.linspace(0., float(T), float(T), endpoint=False)
    yerr = np.zeros_like(tlist)
    y = np.divide(np.divide(err_2pt,mean_2pt)[0],np.divide(err_2pt,mean_2pt)[1])
    ana.plot_data(tlist, np.divide(err_2pt,mean_2pt), yerr, err_single, label,[0,T])
    label[2] = r'$\delta (C_{4C})/C_{4C}$'
    ana.plot_data(tlist, np.divide(err_4pt_c,mean_4pt_c), yerr, err_single, label,[5,60])
    label[2] = r'$\delta (C_{4D})/C_{4D}$'
    ana.plot_data(tlist, np.divide(err_4pt_d,mean_4pt_d), yerr, err_single, label,[5,60])
    err_single.close()
   
    





# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print("Keyboard Interrupt")
