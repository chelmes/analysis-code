#!/usr/bin/python
################################################################################
#
# Author: Christian Jost (jost@hiskp.uni-bonn.de),
#         Christopher Helmes (helmes@hiskp.uni-bonn.de)
# Date:   October 2015
#
# Copyright (C) 2015 Christian Jost, Christopher Helmes
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: A short comparison of 2 pt and 4 pt correlation functions.
#
# For informations on input parameters see the description of the function.
#
################################################################################

import matplotlib
matplotlib.use('Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np
import math
import analysis as ana

def main():
  ## definition of some variables
    nbsamples = 500
    T = 64
    T2 = int(T/2)+1
    massfunc = lambda p, t: p

    # get mean correlators of 2 and 4pt function to compare

    #cmp_quant = ["3_rnd_vec/data/","4_rnd_vec/data/","5_rnd_vec/data/"]
    cmp_quant = ["s_1_rnd_vec/amu_s_225/","s_2_rnd_vec/amu_s_225/","s_3_rnd_vec/amu_s_225/"]
    nb_obs = len(cmp_quant)
    #path_pipi = "/hiskp2/helmes/pi-pi-scattering/tests/A40.24/"
    #path_kk = "/hiskp2/helmes/k-k-scattering/tests/A40.24/"
    path_k = "/hiskp2/helmes/analysis/mass/kaon/data/A30.32/"
    #plotpath_pi = path_pipi+"plots/"
    plotpath_k = "/hiskp2/helmes/analysis/mass/kaon/plots/A30.32/"
    # Arrays for different configuration subsets
    # shape is ( nb_quant, time, dat_type)
    mean_corr_2pt = np.zeros((nb_obs, T2-2, 2))
    #mean_corr_4pt = np.zeros((nb_obs, T2-2, 2))
    #rat_array = np.zeros((nb_obs, T2-1))
    rel_err_c2 = np.zeros((nb_obs, T2))
    #rel_err_c4 = np.zeros_like(rel_err_c2)
    tlist_corr = np.linspace(0., float(T2-2), float(T2-2), endpoint=False)
#    test = PdfPages("quicktest.pdf")
#    for _e in range(nb_obs):
#        name_2pt = path_kk+cmp_quant[_e]+"k_corr_p0.dat"
#        name_4pt = path_kk+cmp_quant[_e]+"kk_A1_TP0_00.dat"
#        corrs_2pt = ana.read_data_ascii(name_2pt)
#        corrs_4pt = ana.read_data_ascii(name_4pt)
#
#        c2pt_mean, c2pt_err = ana.calc_error(corrs_2pt)
#        c4pt_mean, c4pt_err = ana.calc_error(corrs_4pt)
#
#        tlist = np.linspace(0., float(T), float(T), endpoint=False)
#        p = plt.errorbar(tlist,c4pt_mean,c4pt_err, fmt='x')
#
#    plt.grid(True)
#    plt.yscale('log')
#    test.savefig()
#    test.close()

    for _e in range(0,nb_obs):
        #name_pi_2pt = path_pipi+cmp_quant[_e]+"pi_corr_p0.dat"
        name_2pt = path_k+cmp_quant[_e]+"k_charged_p0.dat"
        #name_pi_4pt = path_pipi+cmp_quant[_e]+"pipi_A1_TP0_00.dat"
        #name_4pt = path_kk+cmp_quant[_e]+"kk_A1_TP0_00.dat"
        print ("Reading:\n%s" % (name_2pt))
        corrs_2pt = ana.read_data_ascii(name_2pt)
        #corrs_4pt = ana.read_data_ascii(name_4pt)

        bsamples_2pt =  ana.sym_and_boot(corrs_2pt,nbsamples)
        #bsamples_4pt =  ana.sym_and_boot(corrs_4pt,nbsamples)

        corr_2pt_data, d_2pt_data = ana.calc_error(bsamples_2pt)
        #corr_4pt_data, d_4pt_data = ana.calc_error(bsamples_4pt)

        # compute effective masses
        m_eff_2pt, mm_eff_2pt, err_m_eff_2pt = ana.compute_mass(bsamples_2pt) 
        #m_eff_4pt, mm_eff_4pt, err_m_eff_4pt = ana.compute_mass(bsamples_4pt)
        #print mm_eff_2pt, mm_eff_4pt

        # compute ratio (C4/C2^2)(dt+1/2)
        #rat, mean_rat, err_rat = ana.simple_ratio_subtract(bsamples_4pt,
        #                                       bsamples_2pt,bsamples_2pt)
        # plot effective masses
        save_plt = "%s%sm_eff.pdf" % ( plotpath_k,cmp_quant[_e]) 
        pfit = PdfPages(save_plt)
        print "Save effective mass plot to %s" % save_plt

        tlist_corr = np.linspace(0., float(T2-2), float(T2-2), endpoint=False)
        label_2pt = ["Effective Mass", "time", "m_eff_2pt(t)", "2pt", cmp_quant[_e]]
        #label_4pt = ["Effective Mass", "time", "m_eff_4pt(t)", "4pt", cmp_quant[_e]]

        ana.plot_data(tlist_corr, mm_eff_2pt, err_m_eff_2pt,pfit, label_2pt, [1,T2])
        #ana.plot_data(tlist_corr, mm_eff_4pt, err_m_eff_4pt,pfit, label_4pt, [1,T2])
        pfit.close()

        # append stuff to array
        #mean_corr_2pt [_e,:, 0] = corr_2pt_data
        #mean_corr_2pt [_e,:, 1] = d_2pt_data   
        #mean_corr_4pt [_e,:, 0] = corr_4pt_data
        #mean_corr_4pt [_e,:, 1] = d_4pt_data   
        mean_corr_2pt [_e,:, 0] = mm_eff_2pt
        mean_corr_2pt [_e,:, 1] = err_m_eff_2pt
        #mean_corr_4pt [_e,:, 0] = mm_eff_4pt
        #mean_corr_4pt [_e,:, 1] = err_m_eff_4pt
        rel_err_c2 [_e,:] = np.divide(d_2pt_data,corr_2pt_data)
        #rel_err_c4 [_e,:] = np.divide(d_4pt_data,corr_4pt_data)
        #rat_array [_e,:] = np.divide(err_rat,rat[0])


    # relative error
    rel_err_2pt = np.divide(mean_corr_2pt[:,:,1], mean_corr_2pt[:,:,0])

    #rel_err_4pt = np.divide(mean_corr_4pt[:,:,1], mean_corr_4pt[:,:,0])
    print rel_err_2pt.shape

    # Noise to signal ratios i vs j configs
    nsr_2pt = np.divide(rel_err_2pt[1], rel_err_2pt[2] )
    #nsr_4pt = np.divide(rel_err_4pt[1], rel_err_4pt[2] )

    # plot mean and stdev
    # zeros for the y-error in the plots
    dY = np.zeros_like(nsr_2pt)
    print len(tlist_corr)
    pfit = PdfPages("%s%s_plot.pdf" % (plotpath_k,"rel_err_"))
    for _e in range(0,nb_obs):
        rnd_lbl = "%d rnd vecs" % _e
        label_2pt = ["rel_error", "time", "dm_eff_2pt(t)/m_eff_2pt(t)",
                    [rnd_lbl]]
        #label_4pt = ["rel_error", "time", "dm_eff_4pt(t)/m_eff_4pt(t)",
        #            [rnd_lbl], cmp_quant[_e]]

        ana.plot_data(tlist_corr, rel_err_2pt[_e],dY,pfit, label_2pt, [1,T2])
        #ana.plot_data(tlist_corr, rel_err_4pt[_e],dY,pfit, label_4pt, [1,T2])
    pfit.close()
    
    label_2pt = ["Ratio rel. errors", "time", "NSR_2pt(t)", ["4:5 rnd vecs"]]
    #label_4pt = ["Ratio rel. errors", "time", "NSR_4pt(t)", ["4:5 rnd vecs"],
    #            cmp_quant[0] +" : "+ cmp_quant[2]]
    pfit = PdfPages("%s%s_plot.pdf" % (plotpath_k,"NSR_"))
    ana.plot_data(tlist_corr, nsr_2pt, dY, pfit, label_2pt, [1,T2])
    #ana.plot_data(tlist_corr, nsr_4pt, dY, pfit, label_4pt, [1,T2],hann = [5.,4.])
    pfit.close()

    # Average relative error of correlators and ratio over time extent for all three random vector
    # numbers
    corr_2pt_avg_t = np.asarray([ana.calc_error(mc2) for mc2 in mean_corr_2pt])
    #corr_4pt_avg_t = np.asarray([ana.calc_error(mc4) for mc4 in mean_corr_4pt])
    #print rat_array.shape
    #ratio_avg_t = np.asarray([ana.calc_error(ra,0) for ra in rat_array])
    #print ratio_avg_t[:,0]
    # plot all random vectors in one plot

    plt_label=[r'$N_R=1$',r'$N_R=2$',r'$N_R=3$']
    #rat_label = [r'rel_error',r'$t+0.5$',r'dR/R',plt_label]
    c2_label = [r'rel_error',r'$t$',r'dC_2/C_2',plt_label]
    #c4_label = [r'rel_error',r'$t$',r'dC_4/C4',plt_label]
    #tlist_rat = np.linspace(0.5, float(T2-0.5), float(T2-1), endpoint=False)
    #print tlist_rat
    #print rat_array
    rnd_cmp = PdfPages("%s%s_plot.pdf" %(plotpath_k, "C2_err_cmp"))
    print rel_err_c2.shape
    ana.plot_data(tlist_corr, rel_err_c2,np.zeros(T2), rnd_cmp,
                  c2_label, plotrange=[2,T2-2])
    rnd_cmp.close()
    #rnd_cmp = PdfPages("%s%s_plot.pdf" %(plotpath_k, "C4_err_cmp"))
    #ana.plot_data(tlist_corr, rel_err_c4,np.zeros(23), rnd_cmp,
    #              rat_label, plotrange=[1,T2-2])
    #rnd_cmp.close()
    #rnd_cmp = PdfPages("%s%s_plot.pdf" %(plotpath_k, "err_cmp"))
    #ana.plot_data(tlist_rat, rat_array,np.zeros(25), rnd_cmp,
    #              rat_label, plotrange=[2,T2-1])
    #rnd_cmp.close()
 
    #for a in range(0,2):
    #    for b in range(0,2):
    #        if ( a == b ):
    #            continue
    #        if (a < b):
    #            i, j = cmp_quant[b], cmp_quant[a]
    #            #rat = math.sqrt(float(j)/float(i))
    #            label_2pt = ["Stat. error growth 2pt", "time", "NSR_hi/NSR_low", "data", "#cfg: "+str(i)+" vs. "+str(j)]
    #            label_4pt = ["Stat. error growth 4pt", "time", "NSR_hi/NSR_low", "data", "#cfg: "+str(i)+" vs. "+str(j)]
    #            nsr_2pt = np.divide(rel_err_2pt[b], rel_err_2pt[a] )
    #            nsr_4pt = np.divide(rel_err_4pt[b], rel_err_4pt[a] )
    #            ana.corr_fct(tlist_corr, nsr_2pt, [1,T2], label_2pt, pfit)
    #            ana.corr_fct(tlist_corr, nsr_4pt, [1,T2], label_4pt, pfit)
    #            #ana.corr_fct(tlist_corr, rel_err_4pt, [1,T2], label_4pt, pfit)
    #pfit.close()



# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    print("Keyboard Interrupt")
