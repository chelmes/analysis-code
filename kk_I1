#!/usr/bin/python
################################################################################
#
# Author: Christopher Helmes (helmes@hiskp.uni-bonn.de)
# Date:   Februar 2015
#
# Copyright (C) 2015 Christopher Helmes
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: Pi-Pi-scattering analysis in the center of mass frame 
#
# For informations on input parameters see the description of the function.
#
################################################################################

# system imports
from scipy import stats
import numpy as np
from numpy.polynomial import polynomial as P
import matplotlib
matplotlib.use('QT4Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

# Christian's packages
import analysis as ana

def main():
    # number of bootstrap samples
    nbsamples = 1500
    # temporal lattice extent
    tmin = 1
    T = 48
    L = 24
    # Strange quark masses and unitary kaon mass
    mk_unit = 0.26695
    dmk_unit = 0.00052
    amu_s = [0.0185,0.0225,0.02464]
<<<<<<< HEAD
    #ensemblelist = ['A40.24/','A60.24/','A80.24/','A100.24/']
    ensemblelist = ['A40.24/']
    filelist = ['k_corr_p0.dat','kk_A1_TP0_00.dat']
    pathroot ="/hiskp2/helmes/k-k-scattering/"
    for ens in ensemblelist:
        datapath = pathroot+"data/"+ens
        print datapath
        #Numpy array to hold all data at end
        m_k_dat = np.zeros((len(amu_s), nbsamples))
        a_k_dat = np.zeros((len(amu_s), nbsamples))
        m_k_unit = np.zeros(nbsamples)

        print("amu_s\tm_k +/- d_stat(m_k)\ta_kk +/- d_stat(a_kk)\tm_k*a_kk +/- d_stat(m_k*a_kk)") 
        for s in range(0,len(amu_s)):
            #set up paths for data read in and result storage
            path = datapath+"amu_s_"+str(amu_s[s])[3:]+"/"
            tmp_out = pathroot+"plots/"+ens+"amu_s_"+str(amu_s[s])[3:]
            pfit = PdfPages("%s%sk_plot.pdf" % (tmp_out,"_corr_")) 
            prat = PdfPages("%s%skk_plot.pdf" % (tmp_out,"_ratio_")) 
            # start with usual analysis (thermal states contamination expected)
            fitfunc = lambda p,t: 10e6 if p[1] < 0.0 else 0.5*p[0]*p[0]*(np.exp(-p[1]*t) + np.exp(-p[1]*(T-t)))
            par_mass = [0.26]
            par_ratio = [2.,0.03,0.3]
            massfunc = lambda p, t: p
            
            # read in data
            corrs_k = ana.read_data_ascii("".join((path, filelist[0])))
            corrs_kk = ana.read_data_ascii("".join((path, filelist[1])))
            nbcfg = corrs_k.shape[0]
            T = corrs_k.shape[1]
            
            # Create symmetrized bootstrap samples of 2pt and 4pt Corr-function
            T2=int(T/2)+1
            tlist_corr = np.linspace(0., float(T2), float(T2), endpoint=False)
            tlist_ratio = np.linspace(0.5, float(T2-0.5), float(T2-1), endpoint=False)
            bsamples_k = ana.sym_and_boot(corrs_k, nbsamples)
            bsamples_kk = ana.sym_and_boot(corrs_kk, nbsamples)

            # Check mean correlators
            corr_k_data, d_k_data = ana.calc_error(bsamples_k)
            corr_kk_data, d_kk_data = ana.calc_error(bsamples_kk)

            # get m_k from bsamples_k
            label = ["single Kaon, "+ens, "time", "C(t)", "data", ""]
            up=T2-1

            # due to small variance changes can fit single correlators to the end
            #for lo in range(12, bsamples_k.shape[1]-11):
            #   res, chi2, pval = fit.fitting(fitfunc, tlist_corr[lo:up], bsamples_k[:,lo:up], par_mass, verbose=1)
            #   print("%2d-%2d: p-value %.7lf, chi2/dof %.7lf, E %.7lf" % (lo, up,
            #       pval[0], chi2[0]/(len(tlist_corr[lo:up])-2), res[0,1]))
            #   fitlabel = "fit %d:%d" % (lo, up-1)
            #   label[3] = fitlabel
            #   fit.corr_fct_with_fit(tlist_corr, bsamples_k[0], d_k_data, fitfunc, res[0],
            #                              [1,T2-2], label, pfit, True, False, [lo,up])
            mass, mmass, dmass = ana.compute_mass(bsamples_k, True)
            #fit.scan_fit_range(massfunc, tlist_corr,mass, par_mass)
            res, chi2, pval = ana.fitting(massfunc,tlist_corr[10:up], mass[:,10:up],
                    par_mass,verbose=0)
            ana.corr_fct_with_fit(tlist_corr[:-2], mmass, dmass, massfunc, res[0],
                                 [1,T2], label, pfit, False, False)
            #print("m_k = %e +/- %e" %(np.median(res),np.std(res)))

            pfit.close()
            m_k_dat[s] = res[:,0]

            # compute Ratio of finite differences of C_kk and C_k^2
            #--------------------------------------------------------------------------
            R_boot, R_mean, R_stdev, = ana.simple_ratio_subtract(bsamples_kk, bsamples_k, bsamples_k)
            # initial p (A, deltaE, E_k)
            label = ["Ratio K-K, "+ens, "time", "R(t)", "data", ""]
            #define the ratiofunction
            #ratio = lambda p, t, e : p[0]*(np.cosh(p[1]*(t-T/2))+np.sinh(p[1]*(t-T/2))/(np.tanh(2*e*(t-T/2))))
            ratio = lambda p, t : p[0]*(np.cosh(p[1]*(t-T/2))+np.sinh(p[1]*(t-T/2))/(np.tanh(2*p[2]*(t-T/2))))
            # define fit ranges
            lobound = 12
            upbound = 22
            #for lo in range(lobound, bsamples_k.shape[1]-5):
            #  for up in range(lo+11, bsamples_k.shape[1]):
            ana.scan_fit_range(ratio,tlist_ratio,R_boot,par_ratio)
            #res_R, chi2_R, pvals_R = ana.fitting(ratio, tlist_ratio[14:],
            #      R_boot[:,14:], par_ratio, None, verbose=1)
            #print("%2d-%2d: p-value %.7lf, chi2/dof %.7lf, delta E %.7lf" % (lobound,
            #    upbound,
            #     pvals_R[0], chi2_R[0]/(len(tlist_ratio[lobound:upbound])-2), res_R[0,1]))
            fitlabel = "fit %d:%d" % (lobound, upbound-1)
            label[3] = fitlabel
            #define the ratiofunction for plotting (median at moment)
            param_plt = [np.median(res_R[:,0]),np.median(res_R[:,1]),np.median(res_R[:,2])]
            print param_plt
            #ratio_plt = lambda p, t : p[0]*(np.cosh(p[1]*(t-T/2))+np.sinh(p[1]*(t-T/2))/(np.tanh(2*p[2]*(t-T/2))))
            ana.corr_fct_with_fit(tlist_ratio, R_mean, R_stdev, ratio,
                param_plt, [1,T2],
                     label, prat, False, False, [lobound,upbound]) 

            prat.close()
            a_k_dat[s] = ana.calc_scat_length(res_R[:,1],m_k_dat[s],L)
            m_k_akk = a_k_dat[s]*m_k_dat[s]
            print("%f\t%f +/- %e\t%f +/- %e\t%f +/- %e"%(amu_s[s], np.median(m_k_dat[s]), np.std(m_k_dat[s]),
            np.median(a_k_dat[s]), np.std(a_k_dat[s]), np.median(m_k_akk),
            np.std(m_k_akk) ))
=======
    # get m_k from single_corr_analysis
    #path = "/hiskp2/helmes/contractions/A40.24/kaon/merged/"
    #pathroot = "/home/christopher/studium/PROMO/data/correlators/scattering/k-k/A40.24/mu_s_"
    #tmp_outroot = "/home/christopher/studium/PROMO/results/correlators/scattering/k-k/A40.24/mu_s_"
    pathroot = "/hiskp2/correlators/A40.24_L24_T48_beta190_mul0040_musig150_mudel190_kappa1632700/ev120/k-k/mu_s_"
    #tmp_outroot = "/hiskp2/helmes/correlators/A40.24/kaon/mu_s_"
    tmp_outroot = "./mu_s_"

    #Numpy array to hold all data at end
    m_k_dat = np.zeros((len(amu_s), nbsamples))
    a_k_dat = np.zeros((len(amu_s), nbsamples))
    m_k_unit = np.zeros(nbsamples)

    for s in range(0,len(amu_s)):
        path = pathroot+str(amu_s[s])[3:]+"/"
        tmp_out = tmp_outroot+str(amu_s[s])[3:]+"/"
        pfit = PdfPages("%s%sk_plot.pdf" % (tmp_out,"corr_")) 
        prat = PdfPages("%s%skk_plot.pdf" % (tmp_out,"ratio_")) 
        filelist = ['k_corr_p0.dat','kk_A1_TP0_00.dat']
        # start with usual analysis (thermal states contamination expected)
        fitfunc = lambda p,t: 10e6 if p[1] < 0.0 else 0.5*p[0]*p[0]*(np.exp(-p[1]*t) + np.exp(-p[1]*(T-t)))
        par_mass = [0.26]
        par_ratio = [2.,0.03]
        massfunc = lambda p, t: p
>>>>>>> c98ee5067a67cc215d2827fe5b09a5a4a716babf
        
        # End data acquisition
        #---------------------------------------------------------------------------

        # Start analysis
        #---------------------------------------------------------------------------

        # reshape data by switching axes
        a_k_fin = a_k_dat.T
        m_k_fin = m_k_dat.T

        # Unitary mass matching of amu_s
        # fit samples to straight line
        #linear fitfunction
        par_match = [0.1,2.]
        m_k2 = lambda p, mu : p[0]*mu+p[1]
        res_m2, chi2_m2, pvals_m2 = ana.fitting(m_k2,
            np.asarray(amu_s)[1:], m_k_fin[:,1:]**2, par_match, None, False, False)

        # Create parametrized bootstrap samples for unitary mass
        mk_u = np.random.normal(mk_unit, dmk_unit, len(corrs_k[0]))
        m_k_unit = ana.bootstrap(mk_u, nbsamples)
        # extract nb_samples amu_s values
        amu_s_fin = (m_k_unit**2-res_m2[:,1])/res_m2[:,0] 
        # print out mean and standard deviation
        #print("amu_s from unitary Kaon matching:")
        #print("amu_s^unit: %f +/- %f\n" % (np.median(amu_s_fin), np.std(amu_s_fin)))
        
        # Extract a_kk*am_k
        par_match = [0.5,-2]
        res_makk, chi2_makk, pvals_makk = ana.fitting(m_k2,
            np.asarray(amu_s)[1:], a_k_fin[:,1:]*m_k_fin[:,1:], par_match, None,
            False, False)
        akk_mk = res_makk[:,1]+res_makk[:,0]*amu_s_fin
        #print("Extracted m_k*a_kk:")
        #print("m_k*akk: %f +/- %f\n" % (np.median(akk_mk), np.std(akk_mk)))
        ##plot data
        #pscat = PdfPages("%s%skk_.pdf" % (tmp_out,"a_"))
        ##fit linear functions
        #coef,stats = P.polyfit(scat_dat[:,0], scat_dat[:,1]**2,1,None,True,scat_dat[:,2]**2)
        #print(coef, stats)
        ##linear fitfunction
        #m_k2 = lambda p, mu : p[0]*mu+p[1]
        ##plot data with linear regression
        #m_k_sq = ["Kaon scatt. length",  "a_mu_s", "m_K^2","A40.24", "data", ""]
        #
        #ana.corr_fct_with_fit(scat_dat[:,0],scat_dat[:,1]**2,scat_dat[:,2]**2,m_k2,
        #    coef[::-1], [0,2],m_k_sq, pscat, False, False, [0.0185,0.02464])
        #pscat.close()


# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Keyboard Interrupt")
