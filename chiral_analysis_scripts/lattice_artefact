#!/hadron/knippsch/Enthought/Canopy_64bit/User/bin/python

################################################################################
#
# Author: Christopher Helmes (helmes@hiskp.uni-bonn.de)
# Date:   July 2017
#
# Copyright (C) 2017 Christopher Helmes
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Test size of the lattice artifact in ChPT extrapolations
# 
# The three ensembles B55.32 A80.24 and D45.32 are nearly at the same physical
# pion mass. They can be used to check the dpendence on lattice artefacts. To do
# so we first need to fix the strange quark mass
#
################################################################################
# system imports
import sys
from scipy import stats
from scipy import interpolate as ip
import numpy as np
from numpy.polynomial import polynomial as P
import math
import matplotlib
matplotlib.use('Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.backends.backend_pdf import PdfPages

# Christian's packages
sys.path.append('/hiskp2/helmes/projects/analysis-code/')
import analysis2 as ana

def line_err(p, x, y, error):
    chi_a = y.A - line(p,x.A)
    chi_b = y.B - line(p,x.B)
    chi_d = y.D - line(p,x.D)
    # and append them to a vector
    return np.dot(error,np.r_[chi_a,chi_b,chi_d])

def line(p,x,add=None):
    if p.ndim == 2 and p.shape[0]> p.shape[1]:
        _args = p.T
    else:
        _args=p
    _res = x[:,0]*_args[0]+_args[1]
    if add is not None:
        _ret = np.r_[_res,np.atleast_2d(add)]
    else:
        _ret = _res
    return _ret

def line_plot(p,x):
    res = p[:,0]*x+p[:,1] 
    return res

def main():
    # Get parameters from initfile
    if len(sys.argv) < 2:
        ens = ana.LatticeEnsemble.parse("A40.24.ini")
    else:
        ens = ana.LatticeEnsemble.parse(sys.argv[1])

    # get data from input file
    lat = ens.name()
    latA = ens.get_data("namea")
    latB = ens.get_data("nameb")
    latD = ens.get_data("named")
    strangeA = ens.get_data("strangea")
    strangeB = ens.get_data("strangeb")
    strangeD = ens.get_data("stranged")
    space=['A','B','D']
    lat_dict = {'A':latA,'B':latB,'D':latD}
    seeds = [3250, 6086, 3765, 7285, 3754, 5526]
    seeds2 = [6272, 1577, 4725, 2352, 4000, 4103, 3925, 7560]
    #dicitionary of light quark masses
    amulA = ens.get_data("amu_l_a")
    amulB = ens.get_data("amu_l_b")
    amulD = ens.get_data("amu_l_d")
    amu_l_dict = {'A': amulA,'B': amulB, 'D': amulD}

    #dictionary of strange quark masses
    mu_s_dict = {'A': strangeA,'B': strangeB, 'D': strangeD}
    amusA = ens.get_data("amu_s_a")
    amusB = ens.get_data("amu_s_b")
    amusD = ens.get_data("amu_s_d")
    amu_s_dict = {'A': amusA,'B': amusB, 'D': amusD}
    print(amu_s_dict)
    datadir = ens.get_data("datadir") 
    plotdir = ens.get_data("plotdir") 
    resdir = ens.get_data("resultdir") 
    nboot = ens.get_data("nboot")
    # Prepare inputs
    ext_data = ana.ExtDat(seeds,space,1)
    #cont_dat = ana.ContDat(seeds2,zp_meth="phys")
    fpi_raw = ana.read_extern("../plots2/data/fpi.dat",(1,2))
    print(fpi_raw)
    #zp_meth="phys"
    zp_meth=1
    #############################################################################
    #                    Matching 
    #############################################################################
    #------------------------- Setup objects -----------------------------------
    #TODO: could that be generalized?

    disc_eff = ana.ChirAna("mu_a32_at_mk_mpi_diff_zp1",match=True,
                            correlated=False,combined=False,debug=0)
    # have two x-values: mpi,r0
    ens_shape_disc_eff = (len(latA),len(latB),len(latD))
    print(ens_shape_disc_eff)
    lyt_xvals = (3,ens_shape_disc_eff,1,3,1500)
    lyt_yvals = (3,ens_shape_disc_eff,1,1,1500)
    disc_eff.create_empty(lyt_xvals,lyt_yvals,lat_dict=lat_dict)
    cont_data = ana.ContDat(seeds2, zp_meth)
    r0mkdiff_sq = ana.r0mk_mpi_diff_phys(cont_data)
    print("Physical value of M_S^2:")
    print(ana.compute_error(r0mkdiff_sq))
    print("\n")
    print("\nSetup complete, begin chiral analysis")
    for i,a in enumerate(space):
        print("\nWorking at lattice spacing %s" %a)
        for j,e in enumerate(lat_dict[a]):
            # if using D30.48 modify lowest amus to 0.0115
            if e == 'D30.48':
                print("modifying lowest mu_s values")
                mu_s_dict[a][0] ='amu_s_115' 
                amu_s_dict[a][0]=0.0115
            print("\nMatch ensemble %s" %e)
        #-------------------------- Evaluate at x-values -----------------------------
################### read in M_pi^FSE ###########################################
            mpi_fse = ana.MatchResult("mpi_fse_M1A_%s"%e,save=datadir+'%s/'%e)
            ana.MatchResult.create_empty(mpi_fse,1500,3)
            mpi_names = [datadir+'%s/' % (e) +s+'/fit_pi_unit_%s.npz' % (e) for s in mu_s_dict[a]]
            mpi_fse_meas = ana.init_fitreslst(mpi_names)
            mpi_fse.load_data(mpi_fse_meas,1,amu_s_dict[a],square=False)
            mpi_fse.add_extern_data('../plots2/data/k_fse_mpi.dat',e,square=False,
                                   read='fse_mk',op='div')
            print("\nM_pi:")
            print(mpi_fse.obs[:,0])

################### read in M_K^FSE ############################################
            mksq_fse = ana.MatchResult("mksq_fse_M1A_%s"%e,save=datadir+'%s/'%e)
            ana.MatchResult.create_empty(mksq_fse,1500,3)
            mk_names = [datadir+'%s/' % (e) +s+'/fit_k_unit_%s.npz' % (e) for s in mu_s_dict[a]]
            mksq_fse_meas = ana.init_fitreslst(mk_names)
            mksq_fse.load_data(mksq_fse_meas,1,amu_s_dict[a],square=True)
            mksq_fse.add_extern_data('../plots2/data/k_fse_mk.dat',e,square=True,
                                   read='fse_mk',op='div')
            print("\nM_K^2:")
            print(mksq_fse.obs[:,0])
################### build M_s^{2,FSE} ##########################################
            mssq_fse = ana.MatchResult("mssq_fse_M1A_%s" % e,save = datadir+'%s/'%e)
            ana.MatchResult.create_empty(mssq_fse,1500,3)
            mssq_fse.set_data(mksq_fse.obs,amu_s_dict[a])
            mssq_fse.add_data(np.square(mpi_fse.obs),idx=slice(0,3),op='min',
                          fac=0.5)
            print("\nM_s^2:")
            print(mssq_fse.obs[:,0])

        
################### read in a_3/2 ##############################################
            mua32_fse = ana.MatchResult("mua32_M1A_%s" %e,save=datadir+'%s/'%e)
            ana.MatchResult.create_empty(mua32_fse,1500,3)
            a32_names = [datadir+'%s/' % (e) +s+'/scat_len_TP0_%s.npz' % (e) for s in mu_s_dict[a]]
            mua32_meas = ana.init_fitreslst(a32_names)
            mua32_fse.load_data(mua32_meas,0,amu_s_dict[a],square=False)

################### build mu_piK a_3/2 #########################################
            for s in range(3):
                mua32_fse.obs[s] *= ana.reduced_mass(np.sqrt(mksq_fse.obs[s]),
                                                 mpi_fse.obs[s]) 
            print("\nmu_piK_a32:")
            print(mua32_fse.obs[:,0])
################################################################################
#                   fix strange quark mass                                     #
################################################################################
            
            evl_x = ana.mk_mpi_diff_phys(a, nboot, cont_data, ext_data)
            print("\n(M^2_k-0.5*M^2_pi):")
            print(ana.compute_error(evl_x))
################### interpolate M_K^FSE ########################################
            mksq_fse.amu = mssq_fse.obs
            print("\nM_K^2:")
            print(mksq_fse.obs[:,0])
            label = [r'$a^2(M_K^2-0.5M^2_{\pi})$',r'$M_{K}^2$',
                     r'$a^2(M_K^2-0.5M^2_{\pi}) = (aM_s^{\mathrm{ref}})^2$']
            mksq_fse.eval_at(evl_x,plotdir=plotdir,
                           ens=e,plot=True,label=label, meth=2)

################### interpolate mu_piK a_3/2 ###################################
            mua32_fse.amu = mssq_fse.obs
            label = [r'$a^2(M_K^2-0.5M^2_{\pi})$',r'$\mu_{\pi K}\, a_{3/2}$',
                     r'$a^2(M_K^2-0.5M^2_{\pi}) = (aM_s^{\mathrm{ref}})^2$']
            mua32_fse.eval_at(evl_x,plotdir=plotdir,
                               ens=e,plot=True,label=label, meth=2)
            # Add mu_s values from matching
            disc_eff.add_data(mua32_fse.amu_match[2],(i,j,0,0),'mu')
            # Add Mu a0 data to chiral analysis object 
            disc_eff.add_data(mua32_fse.eval_obs[2],(i,j,0,0),'y')
            # Add Mu/fpi data to chiral analysis object
            mu_fse = ana.reduced_mass(np.sqrt(mksq_fse.eval_obs[2]),
                                      mpi_fse.obs[0])
            print("mu_piK:")
            print(mu_fse[0])
            # Add f_pi data
            dummy, fpi = ana.prepare_fk(fpi_raw,e,1500)
            print("Ensemble %s f_pi: " %e)
            print(ana.compute_error(fpi))
            disc_eff.add_data(fpi,(i,j,0,2),'x')
            disc_eff.add_extern_data("../plots2/data/k_fse_fpi.dat",(i,j,0,2),e,
                                     dim='x',read='k_fse',square=False,
                                     op='div')
            #mufpi= mu_fse/fpi
            #disc_eff.add_data(mufpi,(i,j,0,1),'x')
            ## Multiply finite size effects because f_pi is in denominator
            #disc_eff.add_extern_data("../plots2/data/k_fse_fpi.dat",(i,j,0,1),e,
            #                         dim='x',read='k_fse',square=False,
            #                         op='mult')
            
            disc_eff.add_data(mu_fse,(i,j,0,1),'x')
            # Multiply finite size effects because f_pi is in denominator
            #disc_eff.add_extern_data("../plots2/data/k_fse_fpi.dat",(i,j,0,1),e,
            #                         dim='x',read='k_fse',square=False,
            #                         op='mult')
            # Add 1/r0 values
            disc_eff.x_data[i][j,0,0] = 1/(ext_data.get(a,'r0'))**2
    start = [0.1,0.1]
    disc_eff.fit(line_err,start,plotdir=plotdir)
    
    label=[r'$(a/r_0)^2$',r'$\mu_{\pi K}\,a_{3/2}$',r' ',
           r'$(\mu_{\pi K}/f_{\pi})_{phys}$']
    filename = plotdir+'/mu_a0_disc_eff_set1.pdf'
    chiral_plot = ana.LatticePlot(filename, join = False)
    #limits for x values in plot
    chiral_plot.plot_chiral_ext(disc_eff,space,label,
                                xlim=[0.,0.05],ylim=[-0.35,0.],func=None,
                                kk=False,gamma=True, plotlim = [0.,0.05])
    plotargs=np.vstack((disc_eff.fitres.data[0][:,0,0],disc_eff.fitres.data[0][:,1,0])).T
    print(plotargs.shape)
    chiral_plot.plot_cont(disc_eff,line_plot,xlim=[0.,0.05],
                          args=plotargs,phys=False)
    chiral_plot.save()
    del chiral_plot
    header=["#amu_l","amu_s","mua32","dmua32","(a/r_0)^2"]
    ana.print_summary(disc_eff,header,amu_l_dict,amu_s_dict)
    
    for a in range(len(disc_eff.x_data)):
        disc_eff.y_data[a][:,:,0] = ext_data.get(space[a],'r0')*disc_eff.x_data[a][:,:,1]  
    header=["#amu_l","amu_s","mufpi","dmufpi","(a/r_0)^2"]
    ana.print_summary(disc_eff,header,amu_l_dict,amu_s_dict)
    start = [0.1,0.1]
    disc_eff.fit(line_err,start,plotdir=plotdir)
    
    label=[r'$(a/r_0)^2$',r'$r_0\mu_{\pi K}$',r' ',
           r'$(\mu_{\pi K})_{phys}$']
    filename = plotdir+'/mu_disc_eff_set1.pdf'
    chiral_plot = ana.LatticePlot(filename, join = False)
    #limits for x values in plot
    chiral_plot.plot_chiral_ext(disc_eff,space,label,
                                xlim=[0.,0.05],ylim=[0.5,0.6],func=None,
                                kk=False,gamma=True, plotlim = [0.,0.05])
    plotargs=np.vstack((disc_eff.fitres.data[0][:,0,0],disc_eff.fitres.data[0][:,1,0])).T
    print(plotargs.shape)
    chiral_plot.plot_cont(disc_eff,line_plot,xlim=[0.,1.5],
                          args=plotargs,phys=False)
    chiral_plot.save()
    del chiral_plot
    header=["#amu_l","amu_s","mufpi","dmufpi","(a/r_0)^2"]
    ana.print_summary(disc_eff,header,amu_l_dict,amu_s_dict)

    for a in range(len(disc_eff.x_data)): 
        disc_eff.y_data[a][:,:,0] = ext_data.get(space[a],'r0')*disc_eff.x_data[a][:,:,2]  
    header=["#amu_l","amu_s","mufpi","dmufpi","(a/r_0)^2"]
    ana.print_summary(disc_eff,header,amu_l_dict,amu_s_dict)
    start = [0.1,0.1]
    disc_eff.fit(line_err,start,plotdir=plotdir)
    
    label=[r'$(a/r_0)^2$',r'$r_0f_{\pi}$',r' ',
           r'$(f_{\pi})_{phys}$']
    filename = plotdir+'/fpi_disc_eff_set1.pdf'
    chiral_plot = ana.LatticePlot(filename, join = False)
    #limits for x values in plot
    chiral_plot.plot_chiral_ext(disc_eff,space,label,
                                xlim=[0.,0.05],ylim=[0.3,0.4],func=None,
                                kk=False,gamma=True, plotlim = [0.,0.05])
    plotargs=np.vstack((disc_eff.fitres.data[0][:,0,0],disc_eff.fitres.data[0][:,1,0])).T
    print(plotargs.shape)
    chiral_plot.plot_cont(disc_eff,line_plot,xlim=[0.,1.5],
                          args=plotargs,phys=False)
    chiral_plot.save()
    del chiral_plot
    header=["#amu_l","amu_s","mufpi","dmufpi","(a/r_0)^2"]
    ana.print_summary(disc_eff,header,amu_l_dict,amu_s_dict)
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Keyboard Interrupt")


