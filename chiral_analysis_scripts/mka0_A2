#!/hadron/knippsch/Enthought/Canopy_64bit/User/bin/python

################################################################################
#
# Author: Christopher Helmes (helmes@hiskp.uni-bonn.de)
# Date:   Februar 2016
#
# Copyright (C) 2016 Christopher Helmes
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: Interpolate MK*a0 to the physical value of (M_K^2-0.5M_pi^2) for
# each ensemble.
# After evaluation of all ensembles, MK*a0 is chirally extrapolated to the
# physical value of (r0*M_pi)^2) 
# 
# Function: Combined chiral and continuum extrapolation of (M_K a_0) to the
# physical point.
# The extrapolation works unitless, the later plots can be done using physical
# observables 
# 
# Extrapolation:
# M_K a_0 = p0*(r_0 M_pi)^2 + p1*(a/r_0)^2 + p2
#
# For informations on input parameters see the description of the function.
#
################################################################################

# system imports
import sys
from scipy import stats
from scipy import interpolate as ip
import numpy as np
from numpy.polynomial import polynomial as P
import math
import matplotlib
matplotlib.use('Agg') # has to be imported before the next lines
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.backends.backend_pdf import PdfPages

# Christian's packages
sys.path.append('/hiskp2/helmes/projects/analysis-code/')
import analysis2 as ana

def main():
# Parse the input
  if len(sys.argv) < 2:
      ens = ana.LatticeEnsemble.parse("A40.24.ini")
  else:
      ens = ana.LatticeEnsemble.parse(sys.argv[1])

  # get data from input file
  lat = ens.name()
  latA = ens.get_data("namea")
  latB = ens.get_data("nameb")
  latD = ens.get_data("named")
  strangeA = ens.get_data("strangea")
  strangeB = ens.get_data("strangeb")
  strangeD = ens.get_data("stranged")
  space = ['A','B','D']
  seeds1 = [1269, 4761, 8157, 7783, 2954, 8356]
  seeds2 = [8365, 4477, 2692, 6001]
  #space=['B']
  lat_dict = {'A':latA,'B':latB,'D':latD}
  #print("\nDicitonary for ensemble names:")
  #print(lat_dict)
  #dicitionary of light quark masses
  amulA = ens.get_data("amu_l_a")
  amulB = ens.get_data("amu_l_b")
  amulD = ens.get_data("amu_l_d")
  amu_l_dict = {'A': amulA,'B': amulB, 'D': amulD}
  #dictionary of strange quark masses
  mu_s_dict = {'A': strangeA,'B': strangeB, 'D': strangeD}
  amusA = ens.get_data("amu_s_a")
  amusB = ens.get_data("amu_s_b")
  amusD = ens.get_data("amu_s_d")
  amu_s_dict = {'A': amusA,'B': amusB, 'D': amusD}
  #quark = ens.get_data("quark")
  datadir = ens.get_data("datadir") 
  plotdir = ens.get_data("plotdir") 
  resdir = ens.get_data("resultdir") 
  nboot = ens.get_data("nboot")
  zp_meth = 2
  # Fit loops over bootstrap samples, plot_function doesn't...
  # Fitting functions for Chiral extrapolation function
  lochipt = lambda p,x : p[0]*x[0]+p[1]*x[1]+p[2]
  lochipt_cont = lambda p,x : p[0]*x+p[2]
  # Plotting functions for chiral extrapolation
  plot_lochipt = lambda p,x : p[:,0]*x+p[:,1]+p[:,2]
  plot_lochipt_cont = lambda p,x : p[:,0]*x+p[:,2]

  #############################################################################
  #                    Matching 
  #############################################################################
  
  #------------------------- Setup objects -----------------------------------

  amu_s_ren = ana.ChirAna("MK_a0_at_mk_mpi_diff_zp2",match=True,
                          correlated=False,combined=False)
  # layouts for x and y data
  # Number of ensembles for each lattice spacing
  nb_a = len(latA)
  nb_b = len(latB)
  nb_d = len(latD)
  lyt_r0mpi = (3,(nb_a, nb_b, nb_d),1,2,1500)
  lyt_mka0 = (3,(nb_a, nb_b, nb_d),1,1,1500)
  amu_s_ren.create_empty(lyt_r0mpi,lyt_mka0,match=True,cont_ext =
      lochipt,cont_func = lochipt_cont, plot_cont_ext = plot_lochipt,
      plot_cont_func = plot_lochipt_cont)
  ext_data = ana.ExtDat(seeds1, space,zp_meth) 
  cont_data = ana.ContDat(seeds2, zp_meth) 
  r0mkdiff_sq = ana.r0mk_mpi_diff_phys(cont_data) 
  print(ana.compute_error(r0mkdiff_sq))

  # TODO: think about option summary
  print("\nSetup complete, begin chiral analysis")
  for i,a in enumerate(space):
    print("\nWorking at lattice spacing %s" %a)
    for j,e in enumerate(lat_dict[a]):
      print("\nMatch ensemble %s" %e)

      # if using D30.48 modify lowest amus to 0.0115
      if e == 'D30.48':
        print("modifying lowest mu_s values")
        mu_s_dict[a][0] ='amu_s_115' 
        amu_s_dict[a][0]=0.0115
      # initialize a match result object for matching to match_y
  #-------------------------- Evaluate at x-values -----------------------------
      
      # Evaluation works with M_K a_0 as y-data and a^2 (M^2_K - 0.5 M^2_\pi) as
      # x-data
      # TODO: Only Workaround feasible, use two match results, then copy over
      # y-data of one to x-data of other
      print("\nEvaluate ensemble %s" %e)
      # initialize a match result object for evaluating MK a0
      mk_diff = ana.MatchResult("diff_mk_mpi_zp2")
      ana.MatchResult.create_empty(mk_diff,1500,3)
      # Load data to match each ensemble
      dat_names = [datadir+'%s/' % (e) +s+'/fit_k_%s.npz' % (e) for s in mu_s_dict[a]]
      mk_meas = ana.init_fitreslst(dat_names)
      # load squared kaon mass as y-data
      mk_diff.load_data(mk_meas,1,amu_s_dict[a],square=True,mult=None)
      fse_k = '../plots2/data/k_fse_mk.dat'
      # Apply finite size corrections
      mk_diff.add_extern_data(fse_k,e,idx=None,square=True,read='fse_mk',op='mult')
      print("squared M_K added: %f" % mk_diff.obs[0,0])
      # append squared pion mass from extern data multiplied by 0.5 
      mpi_help = ('../plots2/data/mpi.dat','../plots2/data/k_fse_mpi.dat')
      # Done: need FSE corrections for pion here as well
      mk_diff.add_extern_data(mpi_help,e,idx=None,square=True,read='halfmpi',
                              op='min',fse=True,r0=False)
      print("... after subtraction of 1/2 M_pi: %f" % mk_diff.obs[0,0])

      # get MK a0 for all strange quark masses at once
      mk_akk = ana.MatchResult("mk_a0_M2A_%s" %e,save=datadir+'%s/'%e)
      ana.MatchResult.create_empty(mk_akk,1500,3)
      dat_names = [datadir+'%s/' % (e) +s+'/mk_akk_%s.npz' % (e) for s in mu_s_dict[a]]
      mk_akk_meas = ana.init_fitreslst(dat_names)
      mk_akk.load_data(mk_akk_meas,0,amu_s_dict[a],square=False)
      # Apply finite size corrections
      mk_akk.add_extern_data(fse_k,e,idx=None,square=False,read='fse_mk',op='mult')
      
      # Copy over y-data from mk_diff as new x-data
      mk_akk.amu = mk_diff.obs
      #for k,s in enumerate(amu_s_dict[a]):
      #    r0ms = ana.r0mq_from_amuq(s,a,nboot)
      #    mk_akk.add_data(None,(k,),amu=r0ms)
      #label = [r'$r_0m_s$',r'$M_K a_0$']

      # Evaluate MK a0 at matched amu_s value, we are still in the amu_s
      # interval which allows interpolation
      #label = [r'$a\mu_s$',r'$M_K a_0$']
      label = [r'$a^2(M_K^2-0.5M^2_{\pi})$',r'$M_K a_0$',
               r'$a^2(M_K^2-0.5M^2_{\pi}) = (aM_s^{\mathrm{ref}})^2$']
      #evl_x = ana.mk_mpi_diff_phys(a, nboot, lat=True)
      evl_x = ana.mk_mpi_diff_phys(a, nboot, cont_data, ext_data)
      print(ana.compute_error(evl_x))
      #amu_s = ana.amuq_from_r0mq(mk_diff.amu_match[2], a, nboot)
      #amu_s = mk_diff.amu_match[2]
      mk_akk.eval_at(evl_x,plotdir=plotdir,
                     ens=e,plot=True,label=label, meth=2)

      # Add mu_s values from matching
      amu_s_ren.add_data(mk_akk.amu_match[2],(i,j,0,0),'mu')
      # Add MK a0 data to chiral analysis object 
      amu_s_ren.add_data(mk_akk.eval_obs[2],(i,j,0,0),'y')
      # Add r0ml values
      mq_tmp = np.full((nboot,),amu_l_dict[a][j])
      amu_s_ren.add_data(mq_tmp,(i,j,0,0),dim='x')
      #amu_s_ren.x_data[i][j,0,0] *= (ext_data.get(a,'r0'))
      #amu_s_ren.x_data[i][j,0,0] /= ext_data.get(a,'zp')
      #amu_s_ren.x_data[i][j,0,1] = 1./(ext_data.get(a,'r0')**2)

  # Do a chiral fit
  pr_r0 = np.vstack((ext_data.get('A','r0'),ext_data.get('B','r0'),
                    ext_data.get('D','r0')))
  print("Priors for r0 have shape:")
  print(pr_r0.shape)
  pr_zp = np.vstack((ext_data.get('A','zp'),ext_data.get('B','zp'),
                    ext_data.get('D','zp')))
  print("Priors for zp have shape:")
  print(pr_zp.shape)
  amu_s_ren.fit_mka0(pr_r0,pr_zp,dat=datadir)

  # Calculate physical point
  phys_x = cont_data.get('r0')*cont_data.get('m_l')/197.37
  contfunc = lambda p,x: p[:,2]*x + p[:,4]
  evalfunc = lambda p,x: p[6]*x + p[8]
  amu_s_ren.mka0_phys(evalfunc,phys_x,resdir)

  # Plot chiral fit and continuum function
  filename = resdir+'/'+amu_s_ren.proc_id+'.pdf'
  chiral_plot = ana.LatticePlot(filename, join=False)
  label=[r'$r_0m_l$',r'$M_K a_0$']
  plotargs = amu_s_ren.fitres.data[0]
  args = np.asarray([np.hstack((plotargs[:,0+i],plotargs[:,3+i],plotargs[:,6:,0]))
      for i in range(3)])
  plotfunc = lambda p,x: p[:,2]*x + p[:,3]/p[:,0]**2 + p[:,4]
  print("error for physical r0ml")
  print(ana.compute_error(phys_x))
  chiral_plot.plot_chiral_ext(amu_s_ren,space,label,xlim=[0,0.13],ylim=[-0.45,-0.28],args=args,
                              func=plotfunc,ploterror=False)
  cont_func = lambda p,x: p[:,2]*x + p[:,4]
  chiral_plot.plot_cont(amu_s_ren,cont_func,phys_x,xlim=[0,0.13], args=args[0])
  chiral_plot._set_limits(marks=4)
  chiral_plot.save()
  del chiral_plot
  # fit straight line with ca^2 term
  #_r0ml = cont_data.get('r0')*cont_data.get('m_l')/197.37
  #amu_s_ren.fit(dim=None,index=0,datadir=resdir,plot=True,x_phys=_r0ml,
  #    xcut=None,start=[0.,0.,0.], label=label,
  #    ens=lat_dict,read=False,debug=4,xlim=[0,0.13],ylim=[-0.45,-0.28])
  amu_s_ren.print_summary(None,0,space,lat_dict,amu_s_dict,xcut=15)

# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Keyboard Interrupt")
