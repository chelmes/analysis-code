#!/usr/bin/python
################################################################################
#
# Author: Christian Jost (jost@hiskp.uni-bonn.de)
# Date:   Februar 2015
#
# Copyright (C) 2015 Christian Jost
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with tmLQCD. If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# Function: A short analysis of the single pion.
#
# For informations on input parameters see the description of the function.
#
################################################################################

import input_output as io
import analyze_fcts as af
import fit
import bootstrap
import numpy as np

def main():
    ## definition of some variables
    nbsamples = 10
    inputpath="/hiskp2/jost/correlationfunctions/liuming_pion/"
    outputpath="/hiskp2/jost/correlationfunctions/liuming_pion/D15_new/"
    suffix="pi_corr_p0.dat"
    suffix1="pi_corr_average.dat"
    suffix2="pi_corr_mass.dat"
    inputlist=["D15_new/", "D15_old/", "D15_combined/"]

    fitfunc = lambda p, x: p[0]
    for _i in inputlist:
        # read in data
        corrs, nbcfg, T = io.extract_corr_fct("".join((inputpath, inputlist[0],
                                                     suffix)))
        average = af.average_corr_fct(corrs, nbcfg, T)
        print(average)
        tlist = np.linspace(0., float(np.floor(T/2)), float(np.floor(T/2)), endpoint=False)
        # create bootstrap samples
        bsamples = bootstrap.sym_and_boot(corrs, T, nbcfg, nbsamples)
        print(bsamples.shape)
        # choose fitrange
        lo, up = (bsamples.shape[1]-10), bsamples.shape[1]
        # fit the masses and print information
        #res, chi2, pval = fit.fitting(fitfunc, tlist[lo:up], bsamples[:,lo:up], [0.15])


# make this script importable, according to the Google Python Style Guide
if __name__ == '__main__':
    main()
